Assisti ao v√≠deo `Zelda Survival - 0.0.4` e entendi o problema: a colis√£o no eixo **Y** est√° causando comportamento inesperado ‚Äî o Link ‚Äúsalta‚Äù para posi√ß√µes incorretas ou entra no tile em vez de parar suavemente na borda.

Isso acontece porque o sistema de colis√£o est√° tentando corrigir a posi√ß√£o **depois** da colis√£o j√° ter acontecido, e sem verificar corretamente a dire√ß√£o do movimento.

---

### ‚úÖ Solu√ß√£o adequada: **colis√£o separada por eixo + previs√£o**

A maneira correta (e fiel ao *Link‚Äôs Awakening*) √©:

1. **Mover no eixo X**, verificar colis√£o, corrigir.
2. **Mover no eixo Y**, verificar colis√£o, corrigir.

Esse m√©todo se chama **colis√£o separada por eixo (axis-aligned step)**, e √© usado em jogos 2D cl√°ssicos.

---

### üõ†Ô∏è Implementa√ß√£o passo a passo

#### ‚úÖ 1. Separe o movimento do jogador:

No `_update()`, ao inv√©s de mover o jogador diretamente com:

```js
playerProp.x += velocidade;
playerProp.y += velocidade;
```

Use:

```js
let deltaX = 0;
let deltaY = 0;
const speed = (sprSize / basesprSize);

if (keys["d"]) {
    deltaX += speed;
    if (!keys["w"] && !keys["s"] && !keys["a"]) playerProp.direction = 1;
}
if (keys["a"]) {
    deltaX -= speed;
    if (!keys["w"] && !keys["s"] && !keys["d"]) playerProp.direction = 3;
}
if (keys["w"]) {
    deltaY -= speed;
    if (!keys["a"] && !keys["s"] && !keys["d"]) playerProp.direction = 2;
}
if (keys["s"]) {
    deltaY += speed;
    if (!keys["a"] && !keys["w"] && !keys["d"]) playerProp.direction = 0;
}
```

---

#### ‚úÖ 2. Aplique colis√£o e movimento em dois passos:

```js
// Movimento X
playerProp.x += deltaX;
if (checkCollisionWithObjects(playerProp)) {
    playerProp.x -= deltaX; // desfaz movimento se colidiu
}

// Movimento Y
playerProp.y += deltaY;
if (checkCollisionWithObjects(playerProp)) {
    playerProp.y -= deltaY;
}
```

---

#### ‚úÖ 3. Fun√ß√£o de colis√£o otimizada por tile:

Crie esta fun√ß√£o fora do `_update()`:

```js
function checkCollisionWithObjects(obj) {
    for (let y = 0; y < mapObjList.length; y++) {
        for (let x = 0; x < mapObjList[0].length; x++) {
            const tile = mapObjList[y][x];
            if (tile === 256) continue;

            const tileX = (x * sprSize) + camera.x - (camera.offsetX * (10 * sprSize));
            const tileY = (y * sprSize) + camera.y - (camera.offsetY * (8 * sprSize));

            if (checkCollisionInTiles(obj, tileX, sprSize, tileY, sprSize)) {
                return true;
            }
        }
    }
    return false;
}
```

---

### ‚úÖ Vantagens dessa abordagem:

* O Link vai parar **antes de entrar no tile**.
* A posi√ß√£o fica est√°vel e sem saltos visuais.
* Funciona tanto com colis√£o X quanto Y, separadamente, e √© f√°cil de expandir.

---

### üìå Observa√ß√£o:

Voc√™ pode manter o `checkCollisionInTiles(...)` como est√°, s√≥ vai us√°-lo com essa nova l√≥gica de **verifica√ß√£o antes da corre√ß√£o**, em vez de aplicar "teleporte" for√ßado como no `drawScene()`.

---

Se quiser, posso aplicar essas mudan√ßas diretamente no seu c√≥digo atual e te entregar um bloco final ajustado. Deseja isso?
